"use strict";(self.webpackChunkprotoconf=self.webpackChunkprotoconf||[]).push([[5991],{684:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>R,contentTitle:()=>_,default:()=>T,frontMatter:()=>k,metadata:()=>O,toc:()=>I});var t=o(5893),r=o(3905),a=o(7294),i=o(512),c=o(2466),s=o(6550),l=o(469),u=o(1980),p=o(7392),d=o(12);function g(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function f(e){const{values:n,children:o}=e;return(0,a.useMemo)((()=>{const e=n??function(e){return g(e).map((e=>{let{props:{value:n,label:o,attributes:t,default:r}}=e;return{value:n,label:o,attributes:t,default:r}}))}(o);return function(e){const n=(0,p.l)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,o])}function h(e){let{value:n,tabValues:o}=e;return o.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:o}=e;const t=(0,s.k6)(),r=function(e){let{queryString:n=!1,groupId:o}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!o)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return o??null}({queryString:n,groupId:o});return[(0,u._X)(r),(0,a.useCallback)((e=>{if(!r)return;const n=new URLSearchParams(t.location.search);n.set(r,e),t.replace({...t.location,search:n.toString()})}),[r,t])]}function b(e){const{defaultValue:n,queryString:o=!1,groupId:t}=e,r=f(e),[i,c]=(0,a.useState)((()=>function(e){let{defaultValue:n,tabValues:o}=e;if(0===o.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!h({value:n,tabValues:o}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${o.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const t=o.find((e=>e.default))??o[0];if(!t)throw new Error("Unexpected error: 0 tabValues");return t.value}({defaultValue:n,tabValues:r}))),[s,u]=m({queryString:o,groupId:t}),[p,g]=function(e){let{groupId:n}=e;const o=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,r]=(0,d.Nk)(o);return[t,(0,a.useCallback)((e=>{o&&r.set(e)}),[o,r])]}({groupId:t}),b=(()=>{const e=s??p;return h({value:e,tabValues:r})?e:null})();(0,l.Z)((()=>{b&&c(b)}),[b]);return{selectedValue:i,selectValue:(0,a.useCallback)((e=>{if(!h({value:e,tabValues:r}))throw new Error(`Can't select invalid tab value=${e}`);c(e),u(e),g(e)}),[u,g,r]),tabValues:r}}var v=o(2389);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function j(e){let{className:n,block:o,selectedValue:r,selectValue:a,tabValues:s}=e;const l=[],{blockElementScrollPositionUntilNextRender:u}=(0,c.o5)(),p=e=>{const n=e.currentTarget,o=l.indexOf(n),t=s[o].value;t!==r&&(u(n),a(t))},d=e=>{let n=null;switch(e.key){case"Enter":p(e);break;case"ArrowRight":{const o=l.indexOf(e.currentTarget)+1;n=l[o]??l[0];break}case"ArrowLeft":{const o=l.indexOf(e.currentTarget)-1;n=l[o]??l[l.length-1];break}}n?.focus()};return(0,t.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":o},n),children:s.map((e=>{let{value:n,label:o,attributes:a}=e;return(0,t.jsx)("li",{role:"tab",tabIndex:r===n?0:-1,"aria-selected":r===n,ref:e=>l.push(e),onKeyDown:d,onClick:p,...a,className:(0,i.Z)("tabs__item",y.tabItem,a?.className,{"tabs__item--active":r===n}),children:o??n},n)}))})}function x(e){let{lazy:n,children:o,selectedValue:r}=e;const i=(Array.isArray(o)?o:[o]).filter(Boolean);if(n){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,t.jsx)("div",{className:"margin-top--md",children:i.map(((e,n)=>(0,a.cloneElement)(e,{key:n,hidden:e.props.value!==r})))})}function C(e){const n=b(e);return(0,t.jsxs)("div",{className:(0,i.Z)("tabs-container",y.tabList),children:[(0,t.jsx)(j,{...e,...n}),(0,t.jsx)(x,{...e,...n})]})}function S(e){const n=(0,v.Z)();return(0,t.jsx)(C,{...e,children:g(e.children)},String(n))}const w={tabItem:"tabItem_Ymn6"};function P(e){let{children:n,hidden:o,className:r}=e;return(0,t.jsx)("div",{role:"tabpanel",className:(0,i.Z)(w.tabItem,r),hidden:o,children:n})}const k={id:"consume-config-updates",title:"Consuming Configuration Updates",sidebar_position:4},_="Consuming Configuration Updates",O={id:"consume-config-updates",title:"Consuming Configuration Updates",description:"protoconf provides a gRPC service that allows your application to subscribe to configuration updates. This service is provided by the protoconf agent, which can run in development mode and listen on 0.0.0.0:4300.",source:"@site/docs/consume-config-updates.mdx",sourceDirName:".",slug:"/consume-config-updates",permalink:"/docs/0.1.7/consume-config-updates",draft:!1,unlisted:!1,editUrl:"https://github.com/protoconf/protoconf/tree/main/website/protoconf/docs/consume-config-updates.mdx",tags:[],version:"current",sidebarPosition:4,frontMatter:{id:"consume-config-updates",title:"Consuming Configuration Updates",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Configuration Validation",permalink:"/docs/0.1.7/validation"},next:{title:"Advanced Usage",permalink:"/docs/0.1.7/category/advanced-usage"}},R={},I=[{value:"protoconf Agent",id:"protoconf-agent",level:2},{value:"Code Generation",id:"code-generation",level:2}];function N(e){const n={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",strong:"strong",...(0,r.ah)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"consuming-configuration-updates",children:"Consuming Configuration Updates"}),"\n",(0,t.jsxs)(n.p,{children:["protoconf provides a gRPC service that allows your application to subscribe to configuration updates. This service is provided by the protoconf agent, which can run in development mode and listen on ",(0,t.jsx)(n.code,{children:"0.0.0.0:4300"}),"."]}),"\n",(0,t.jsx)(n.p,{children:"This guide will walk you through how to subscribe to configuration updates using the protoconf agent in various languages: Go, Python, Node.js, Rust, and Java."}),"\n",(0,t.jsx)(n.h2,{id:"protoconf-agent",children:"protoconf Agent"}),"\n",(0,t.jsx)(n.p,{children:"To start the protoconf agent in development mode, use the following command:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"protoconf agent -dev .\n"})}),"\n",(0,t.jsx)(n.p,{children:"The protoconf agent implements the following gRPC service:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-protobuf",children:'syntax = "proto3";\npackage v1;\n\noption java_package = "com.protoconf.agent.api.v1";\n\nimport "google/protobuf/any.proto";\n\nmessage ConfigSubscriptionRequest {\n    string path = 1;\n}\n\nmessage ConfigUpdate {\n    google.protobuf.Any value = 1;\n}\n\nservice ProtoconfService{\n    rpc SubscribeForConfig(ConfigSubscriptionRequest) returns (stream ConfigUpdate);\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can use it as a dependency from buf: ",(0,t.jsx)(n.code,{children:"buf.build/protoconf/protoconf"}),"."]}),"\n",(0,t.jsx)(n.h2,{id:"code-generation",children:"Code Generation"}),"\n",(0,t.jsxs)(n.p,{children:["Before consuming the configuration updates, you need to generate code from the proto file. A simple solution for this is using ",(0,t.jsx)(n.code,{children:"buf"}),". Here is the content for ",(0,t.jsx)(n.code,{children:"buf.yaml"})," and ",(0,t.jsx)(n.code,{children:"buf.gen.yaml"}),":"]}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"buf.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"version: v1\nname: buf.build/myusername/myrepository\ndeps:\n  - buf.build/protoconf/protoconf\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"buf.gen.yaml"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"version: v1\nplugins:\n  - name: go\n    out: gen/go\n  - name: java\n    out: gen/java\n  - name: node\n    out: gen/js\n  - name: python\n    out: gen/python\n"})}),"\n",(0,t.jsxs)(n.p,{children:["With the above configurations, run ",(0,t.jsx)(n.code,{children:"buf generate"})," to generate the code for your protobuf files. Now you can consume the configuration updates in your preferred language."]}),"\n",(0,t.jsxs)(S,{children:[(0,t.jsxs)(P,{value:"golang",label:"Go",children:[(0,t.jsx)(n.p,{children:"In Go, use the grpc package to create a client and subscribe to configuration updates:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-go",children:'package main\n\nimport (\n    "context"\n    "log"\n\n    "google.golang.org/grpc"\n    "google.golang.org/grpc/credentials/insecure"\n    "github.com/golang/protobuf/ptypes"\n    pb "gen/go/protoconf/v1"\n    mypb "gen/go/myproject/v1"\n)\n\nfunc main() {\n    conn, err := grpc.Dial("localhost:4300", grpc.WithTransportCredentials(insecure.NewCredentials()))\n    if err != nil {\n        log.Fatalf("Failed to connect: %v", err)\n    }\n    defer conn.Close()\n\n    client := pb.NewProtoconfServiceClient(conn)\n\n    stream, err := client.SubscribeForConfig(context.Background(), &pb.ConfigSubscriptionRequest{\n        Path: "myproject/server_config",\n    })\n    if err != nil {\n        log.Fatalf("Failed to subscribe for config: %v", err)\n    }\n\n    for {\n        configUpdate, err := stream.Recv()\n        if err != nil {\n            log.Fatalf("Error receiving config update: %v", err)\n        }\n\n        var config mypb.ServerConfiguration\n        if err := ptypes.UnmarshalAny(configUpdate.Value, &config); err != nil {\n            log.Fatalf("Failed to unmarshal config update: %v", err)\n        }\n\n        log.Printf("Received config update: %+v", config)\n    }\n}\n'})})]}),(0,t.jsxs)(P,{value:"python",label:"Python",children:[(0,t.jsx)(n.p,{children:"In Python, use the grpc package to create a client and subscribe to configuration updates:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:'from google.protobuf import any_pb2\nfrom grpc import insecure_channel\n\nimport protoconf.v1.protoconf_pb2 as pb\nimport myproject.v1.server_config_pb2 as mypb\n\nwith insecure_channel(\'localhost:4300\') as channel:\n    client = pb.ProtoconfServiceStub(channel)\n    request = pb.ConfigSubscriptionRequest(path="myproject/server_config")\n    for config_update in client.SubscribeForConfig(request):\n        config = mypb.ServerConfiguration()\n        if config_update.value.Is(config.DESCRIPTOR):\n            config_update.value.Unpack(config)\n            print(f"Received config update: {config}")\n'})})]}),(0,t.jsxs)(P,{value:"nodejs",label:"Node.js",children:[(0,t.jsx)(n.p,{children:"In Node.js, use the grpc-js package to create a client and subscribe to configuration updates:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const grpc = require("@grpc/grpc-js");\nconst protoLoader = require("@grpc/proto-loader");\nconst mypb = require("./gen/js/myproject/v1/server_config_pb.js");\n\nconst PROTO_PATH = __dirname + "/gen/js/protoconf/v1/protoconf.proto";\nconst packageDefinition = protoLoader.loadSync(PROTO_PATH, {\n  keepCase: true,\n  longs: String,\n  enums: String,\n  defaults: true,\n  oneofs: true,\n});\n\nconst protoDescriptor = grpc.loadPackageDefinition(packageDefinition);\nconst client = new protoDescriptor.v1.ProtoconfService(\n  "localhost:4300",\n  grpc.credentials.createInsecure()\n);\n\nconst call = client.SubscribeForConfig({ path: "myproject/server_config" });\n\ncall.on("data", (configUpdate) => {\n  const config = mypb.ServerConfiguration.deserializeBinary(\n    configUpdate.value.value\n  );\n  console.log(`Received config update: ${JSON.stringify(config.toObject())}`);\n});\n\ncall.on("error", (error) => {\n  console.error(`Error receiving config update: ${error}`);\n});\n\ncall.on("end", () => {\n  console.log("End of config updates");\n});\n'})})]}),(0,t.jsxs)(P,{value:"rust",label:"Rust",children:[(0,t.jsx)(n.p,{children:"In Rust, use the tonic crate to create a client and subscribe to configuration updates:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-rust",children:'use tonic::transport::Channel;\nuse futures::StreamExt;\nuse prost::Message;\n\nuse protoconf::v1::protoconf_service_client::ProtoconfServiceClient;\nuse protoconf::v1::ConfigSubscriptionRequest;\nuse myproject::v1::ServerConfiguration;\n\n#[tokio::main]\nasync fn main() -> Result<(), Box<dyn std::error::Error>> {\n    let channel = Channel::from_static("http://localhost:4300").connect().await?;\n    let mut client = ProtoconfServiceClient::new(channel);\n\n    let request = tonic::Request::new(ConfigSubscriptionRequest {\n        path: "myproject/server_config".to_string(),\n    });\n\n    let mut stream = client.subscribe_for_config(request).await?.into_inner();\n\n    while let Some(config_update) = stream.message().await? {\n        let config = ServerConfiguration::decode(config_update.value.value.as_slice())?;\n        println!("Received config update: {:?}", config);\n    }\n\n    Ok(())\n}\n'})})]}),(0,t.jsxs)(P,{value:"java",label:"Java",children:[(0,t.jsx)(n.p,{children:"In Java, use the grpc package to create a client and subscribe to configuration updates:"}),(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-java",children:'import io.grpc.ManagedChannel;\nimport io.grpc.ManagedChannelBuilder;\nimport com.google.protobuf.Any;\nimport com.google.protobuf.InvalidProtocolBufferException;\nimport com.protoconf.agent.api.v1.ProtoconfServiceGrpc;\nimport com.protoconf.agent.api.v1.ConfigUpdate;\nimport com.protoconf.agent.api.v1.ConfigSubscriptionRequest;\nimport myproject.v1.ServerConfiguration;\n\npublic class Main {\n    public static void main(String[] args) throws InterruptedException {\n        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", 4300)\n                .usePlaintext()\n                .build();\n\n        ProtoconfServiceGrpc.ProtoconfServiceBlockingStub stub = ProtoconfServiceGrpc.newBlockingStub(channel);\n\n        stub.subscribeForConfig(ConfigSubscriptionRequest.newBuilder().setPath("myproject/server_config").build())\n                .forEachRemaining(configUpdate -> {\n                    try {\n                        ServerConfiguration config = configUpdate.getValue().unpack(ServerConfiguration.class);\n                        System.out.println("Received config update: " + config);\n                    } catch (InvalidProtocolBufferException e) {\n                        System.err.println("Failed to unpack config update: " + e);\n                    }\n                });\n\n        channel.shutdown();\n    }\n}\n'})})]})]}),"\n",(0,t.jsxs)(n.p,{children:["In this example, the ",(0,t.jsx)(n.code,{children:"SubscribeForConfig"})," RPC is used to subscribe for updates to the ",(0,t.jsx)(n.code,{children:"myproject/server_config"})," configuration. The received ",(0,t.jsx)(n.code,{children:"ConfigUpdate"})," messages are unpacked into ",(0,t.jsx)(n.code,{children:"ServerConfiguration"})," objects which can then be used by your application."]}),"\n",(0,t.jsx)(n.p,{children:"These examples provide a starting point for integrating protoconf into your applications. As you adapt these examples to your specific needs, you may find additional resources on the gRPC, protobuf, and protoconf libraries helpful."})]})}function T(e={}){const{wrapper:n}={...(0,r.ah)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(N,{...e})}):N(e)}},3905:(e,n,o)=>{o.d(n,{ah:()=>l});var t=o(7294);function r(e,n,o){return n in e?Object.defineProperty(e,n,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[n]=o,e}function a(e,n){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);n&&(t=t.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),o.push.apply(o,t)}return o}function i(e){for(var n=1;n<arguments.length;n++){var o=null!=arguments[n]?arguments[n]:{};n%2?a(Object(o),!0).forEach((function(n){r(e,n,o[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(o,n))}))}return e}function c(e,n){if(null==e)return{};var o,t,r=function(e,n){if(null==e)return{};var o,t,r={},a=Object.keys(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||(r[o]=e[o]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(t=0;t<a.length;t++)o=a[t],n.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(r[o]=e[o])}return r}var s=t.createContext({}),l=function(e){var n=t.useContext(s),o=n;return e&&(o="function"==typeof e?e(n):i(i({},n),e)),o},u={inlineCode:"code",wrapper:function(e){var n=e.children;return t.createElement(t.Fragment,{},n)}},p=t.forwardRef((function(e,n){var o=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=l(o),g=r,f=d["".concat(s,".").concat(g)]||d[g]||u[g]||a;return o?t.createElement(f,i(i({ref:n},p),{},{components:o})):t.createElement(f,i({ref:n},p))}));p.displayName="MDXCreateElement"}}]);