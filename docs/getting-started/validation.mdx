---
id: validation
title: Configuration Validation
sidebar_position: 3
---

# Configuration Validation

Protoconf provides a way to add validation rules to your configuration. These rules allow you to ensure that the configuration values meet certain criteria before they are used by your application. There are two ways to add validation rules: using annotations in your `.proto` files, or writing separate Starlark validation files.

## Using Annotations for Validation

You can add validation rules directly to your `.proto` files using the `validate/validate.proto` and `buf/validate/validate.proto` annotations. These annotations allow you to specify constraints on your message fields.

First, import the `validate.proto` file in your `.proto` file:

```protobuf
import "validate/validate.proto";
```

Then, you can add validation rules to your message fields using the `validate.rules` option:

```protobuf
message ServerConfiguration {
    int32 max_connections = 1 [(validate.rules).int32.gt = 0];
    double max_payload_size_mb = 2 [(validate.rules).double = {gt: 0.1, lt: 100.0}];
    int32 request_timeout = 3 [(validate.rules).int32.gt = 0];
}
```

These annotations will be checked when the message is deserialized, and if any of the constraints are not met, an error will be thrown. This allows you to catch invalid configurations early, before they cause problems in your application.

## Writing a Validation Rule with Starlark (Advanced)

For more complex validation rules, you can write separate Starlark files with the `-validator` suffix. These files are associated with your configuration using the `add_validator` function.

Create a new Starlark file with the `-validator` suffix. For example, for a configuration defined in `./src/myproject/v1/server_config.proto`, the validation file would be `./src/myproject/v1/server_config.proto-validator`.

In this file, load the configuration message, define a validation function, and then add the validator:

```python title=./src/myproject/v1/server_config.proto-validator
load("//myproject/v1/server_config.proto", "ServerConfiguration")

def validate_server_config(config):
    if config.max_connections < 1:
        fail("max_connections must be at least 1")

    if config.max_payload_size_mb < 0.1 or config.max_payload_size_mb > 100.0:
        fail("max_payload_size_mb must be between 0.1 and 100.0")

    if config.request_timeout.seconds < 1:
        fail("request_timeout must be at least 1 second")

add_validator(ServerConfiguration, validate_server_config)
```

In this example, `validate_server_config` is a function that checks whether `max_connections` is at least 1, `max_payload_size_mb` is between 0.1 and 100.0, and `request_timeout` is at least 1 second. If any of these conditions is not met, the function calls `fail()` with an error message.

After defining the validation function, `add_validator()` is called to associate the validation function with the `ServerConfiguration` message. Now, whenever a `ServerConfiguration` object is created, its values will be validated according to these rules.

With validation in place, you can ensure that your configuration values are always within acceptable ranges, preventing errors due to incorrect configurations.
